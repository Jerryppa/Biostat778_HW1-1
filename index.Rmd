Biostat778_HW1
==============

Homework 1 for Biostat 778

Due: November 13, 2013

## Fast Linear Regression

Write a function called `fastlm()` that fits a linear regression model
to outcome data `y` and predictor data in a matrix `X`.

Your function should have the form

```r
fastlm <- function(X, y, na.rm = FALSE) {
       ## Your code goes here
}
```

The inputs should be `X`, a $n\times p$ matrix, `y`, a vector of
length $n$, and `na.rm`, which indicates whether missing values in `X`
or `y` should be removed.

The function should return a list with the following named elements

- `coefficients`: a vector of the regression coefficients estimated
  using maximum likelihood, i.e. $\hat{\beta}=(X^\prime X)^{-1}X^\prime y$.

- `vcov`: the $p\times p$ covariance of matrix of the estimated
  regression coefficients, i.e. $Var(\hat{\beta})$.

Your function should be **fast**. In particular, it should always run
faster than the `lm.fit()` function in R using the same inputs.

To test your function, try running the following code.

```{r,cache=TRUE}
set.seed(2)
## Generate predictor matrix
n <- 1e5
p <- 500
X <- cbind(1, matrix(rnorm(n * (p - 1)), n, p - 1))

## Coefficents
b <- rnorm(p)

## Response
y <- X %*% b + rnorm(n)

source("fastlm.R")
fit <- fastlm(X, y)
str(fit)
```




## Fast Multivariate Normal Density

Write a function called `dmvnorm()` that evaluates the $k$-dimensional
multivariate Normal density with mean $\mu$ and covariance $S$. The
density function is
$f(x\mid\mu,S)=\exp\left(-\frac{k}{2}\log(2\pi)-\frac{1}{2}\log
|S|-\frac{1}{2}(x-\mu)^\prime S^{-1}(x-\mu)\right)$. 

Your function should have the form

```r
dmvnorm <- function(x, mu, S, log = TRUE) {
        ## Your code here
}
```

where $x$ is a $n\times k$ matrix of points to be evaluated, $\mu$ is
a length $k$ vector of means for the $k$-dimensional Normal, and $S$
is a $k\times k$ covariance matrix. Your function should be written
using R code only and you MAY NOT use any additional packages beyond
the standard base packages that come with R.

Your function should return a vector of length $n$ containing the
values of the multivariate Normal density evaluated at the $n$
points. If `log = TRUE` then you should return the log density at
those points. If `log = FALSE`, then you should return the density
values.

You can assume that $S$ will be symmetric. However, your function
should check to see if $S$ is positive definite. If it is not, then
your function should return the error message `"S is not positive
definite"`.

Your code should be **fast**. In particular, it should work quickly
for large inputs (i.e. when the dimension of $k$ is large). You can
simulate Normal data if you want by using the `mvrnorm()` function
from the **MASS** package.

You can time your function with the `system.time()` function. Calling

```r
system.time(dmvnorm(x, mu, S))
```

will give you the time spent executing your function. In particular,
you are interested in the `user` time.

To test your code, try running the following.

```{r,cache=TRUE}
## Create the covariance matrix
n <- 100
n2 <- n^2
xg <- seq(0, 1, length = n)
yg <- xg
g <- data.matrix(expand.grid(xg, yg))
D <- as.matrix(dist(g))
phi <- 5

S <- exp(-phi * D)
mu <- rep(0, n2)
set.seed(1)
x <- matrix(rnorm(n2), byrow = TRUE, ncol = n2)

source("dmvnorm.R")
dmvnorm(x, mu, S, log = TRUE)
```

